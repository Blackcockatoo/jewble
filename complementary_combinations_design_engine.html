<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flower of Life + Metatron Cube Engine</title>
  <style>
    :root {
      --bg: #050514;
      --text: #e4e8ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 16px;
      background:
        radial-gradient(circle at top, #262b60 0%, #050514 55%, #000000 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", sans-serif;
    }
    h1 {
      margin: 0.4em 0 0.2em;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: 1.05rem;
      text-align: center;
    }
    p.subtitle {
      margin: 0 0 0.9em;
      font-size: 0.86rem;
      opacity: 0.85;
      text-align: center;
      max-width: 760px;
    }
    #canvas-wrapper {
      padding: 8px;
      border-radius: 20px;
      background:
        linear-gradient(135deg,
          rgba(56, 61, 122, 0.95),
          rgba(5, 7, 19, 0.98));
      box-shadow:
        0 0 30px rgba(0, 0, 0, 0.9),
        0 0 80px rgba(27, 206, 255, 0.14);
    }
    #engineCanvas {
      display: block;
      background: #050514;
      border-radius: 14px;
    }
    @media (max-width: 900px) {
      #engineCanvas { width: 100%; height: auto; }
    }
  </style>
</head>
<body>
  <h1>Flower of Life + Metatron Cube Engine</h1>
  <p class="subtitle">
    Hexagonal lattice of equal circles (Flower of Life) plus the 13 Metatron
    centres. The math driving this:
    x = r(√3·i + √3/2·j), y = r(3/2·j), i,j ∈ ℤ, and for Metatron the
    13 centres at radius r and 2r with angles 0°, 60°, …, 300°.
  </p>
  <div id="canvas-wrapper">
    <canvas id="engineCanvas" width="900" height="900"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("engineCanvas");
    const ctx = canvas.getContext("2d");

    // --- Fibonacci 60-digit cycle (for subtle modulation) ---
    function buildFib60() {
      const digits = [];
      let a = 0, b = 1;
      for (let i = 0; i < 60; i++) {
        digits.push(a % 10);
        const next = (a + b) % 10;
        a = b; b = next;
      }
      return digits;
    }
    const FIB60 = buildFib60();

    // ---------- Flower of Life geometry ----------
    function drawFlowerOfLife(cx, cy, Rbig) {
      ctx.save();
      ctx.translate(cx, cy);

      // Outer boundary circle
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1.3;
      ctx.beginPath();
      ctx.arc(0, 0, Rbig, 0, Math.PI * 2);
      ctx.stroke();

      // Circle radius: choose so about 7 across the diameter
      const r = Rbig / 3.5;

      // Hex lattice spacing from the math:
      // x = r(√3·i + √3/2·j), y = r(3/2·j)
      const stepX = Math.sqrt(3) * r;
      const stepY = 1.5 * r;

      const maxI = 4, maxJ = 4;  // enough to fill disc

      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.lineWidth = 0.8;

      for (let i = -maxI; i <= maxI; i++) {
        for (let j = -maxJ; j <= maxJ; j++) {
          const x = stepX * i + (stepX / 2) * j;
          const y = stepY * j;
          const d = Math.hypot(x, y);
          if (d <= Rbig + r * 0.2) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      ctx.restore();
    }

    // ---------- Metatron's Cube geometry ----------
    function getMetatronCenters(r) {
      const centers = [];
      centers.push({ x: 0, y: 0 }); // center

      // inner 6 at radius r
      for (let k = 0; k < 6; k++) {
        const theta = (Math.PI * 2 * k) / 6;
        centers.push({
          x: r * Math.cos(theta),
          y: r * Math.sin(theta)
        });
      }
      // outer 6 at radius 2r
      for (let k = 0; k < 6; k++) {
        const theta = (Math.PI * 2 * k) / 6;
        centers.push({
          x: 2 * r * Math.cos(theta),
          y: 2 * r * Math.sin(theta)
        });
      }
      return centers; // 13 total
    }

    function drawMetatron(cx, cy, rBase, t) {
      ctx.save();
      ctx.translate(cx, cy);

      const spin = t * 0.3;
      ctx.rotate(spin);

      const centers = getMetatronCenters(rBase);

      // Lines between every pair, brightness from Fibonacci digit
      const pairCount = (centers.length * (centers.length - 1)) / 2;
      let pairIndex = 0;

      for (let i = 0; i < centers.length; i++) {
        for (let j = i + 1; j < centers.length; j++) {
          const a = centers[i];
          const b = centers[j];
          const fibDigit = FIB60[pairIndex % 60];
          const alpha = 0.20 + 0.05 * fibDigit / 9;
          ctx.strokeStyle = `rgba(0,0,0,${alpha})`;
          ctx.lineWidth = 1;

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();

          pairIndex++;
        }
      }

      // Blue circles at the 13 centres
      ctx.strokeStyle = "rgba(120,180,255,0.9)";
      ctx.lineWidth = 1;
      const rCircle = rBase * 0.9;
      centers.forEach(c => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, rCircle, 0, Math.PI * 2);
        ctx.stroke();
      });

      ctx.restore();
    }

    // ---------- Animation loop ----------
    function drawFrame(ts) {
      const t = ts / 1000;
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      const cx = w / 2, cy = h / 2;
      const Rbig = Math.min(w, h) * 0.42;

      drawFlowerOfLife(cx, cy, Rbig);
      drawMetatron(cx, cy, Rbig / 3.5, t);

      requestAnimationFrame(drawFrame);
    }

    requestAnimationFrame(drawFrame);
  </script>
</body>
</html>