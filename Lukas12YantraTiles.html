<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fibonacci 60 + Lukas 12 Yantra Tiles</title>
  <style>
    :root {
      --bg: #050514;
      --text: #e4e8ff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 16px;
      background:
        radial-gradient(circle at top, #262b60 0%, #050514 55%, #000000 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", sans-serif;
    }

    h1 {
      margin: 0.4em 0 0.1em;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: 1.15rem;
      text-align: center;
    }

    p.subtitle {
      margin: 0 0 0.9em;
      font-size: 0.9rem;
      opacity: 0.85;
      text-align: center;
      max-width: 760px;
    }

    #controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(5, 5, 25, 0.9);
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.7);
      margin-bottom: 10px;
      font-size: 0.78rem;
    }

    button {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background:
        radial-gradient(circle at top, #383a65 0%, #0d0f24 60%, #04050b 100%);
      color: var(--text);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease,
                  background 0.12s ease;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
    }
    button:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: none;
    }

    #canvas-wrapper {
      padding: 8px;
      border-radius: 20px;
      background:
        linear-gradient(135deg,
          rgba(56, 61, 122, 0.95),
          rgba(5, 7, 19, 0.98));
      box-shadow:
        0 0 30px rgba(0, 0, 0, 0.9),
        0 0 80px rgba(27, 206, 255, 0.14);
      max-width: 100%;
    }

    #yantraCanvas {
      display: block;
      background: #050514;
      border-radius: 14px;
    }

    @media (max-width: 900px) {
      #yantraCanvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <h1>Fibonacci 60 × Lukas 12 – Yantra Tile Wall</h1>
  <p class="subtitle">
    Fibonacci’s 60-digit cycle runs the digits; your Lukas string
    [2,1,3,4,7,1,8,9,7,6,3,9] carves the circle into 12 sectors that
    push and pull the geometry as each tile breathes between
    circle and triangle.
  </p>

  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="shuffleBtn">Shuffle Phases</button>
  </div>

  <div id="canvas-wrapper">
    <canvas id="yantraCanvas" width="960" height="540"></canvas>
  </div>

  <script>
    // -------- 1. Fibonacci 60-digit cycle (mod 10) --------
    function buildFibMod10Cycle() {
      const digits = [];
      let a = 0, b = 1;
      for (let i = 0; i < 60; i++) {
        digits.push(a % 10);
        const next = (a + b) % 10;
        a = b;
        b = next;
      }
      return digits;
    }

    const FIB60 = buildFibMod10Cycle();

    // -------- 2. Lukas string: 12 numbers summing to 60 --------
    // This defines the sector lengths around the 60-digit circle.
    const LUKAS_DIGITS = [2,1,3,4,7,1,8,9,7,6,3,9];

    // Cumulative bounds: [0,2,3,6,...,60]
    const LUKAS_BOUNDS = (() => {
      const bounds = [0];
      let s = 0;
      for (const d of LUKAS_DIGITS) {
        s += d;
        bounds.push(s);
      }
      return bounds;
    })();

    // Which Lukas sector (0–11) does index k (0–59) belong to?
    function sectorForIndex(k) {
      for (let s = 0; s < 12; s++) {
        if (k >= LUKAS_BOUNDS[s] && k < LUKAS_BOUNDS[s + 1]) {
          return s;
        }
      }
      return 11; // fallback; should never hit
    }

    // -------- 3. Colours for digits 0–9 --------
    const digitColors = {
      0: "#0b3c5d", // deep blue
      1: "#ff7f0e", // orange
      2: "#2ca02c", // green
      3: "#d62728", // red
      4: "#9467bd", // purple
      5: "#8c564b", // brown
      6: "#e377c2", // pink
      7: "#7f7f7f", // grey
      8: "#bcbd22", // yellow-green
      9: "#17becf"  // cyan
    };

    const canvas = document.getElementById("yantraCanvas");
    const ctx = canvas.getContext("2d");

    // -------- 4. Tile layout --------
    const TILE_COLS = 4;
    const TILE_ROWS = 3;
    const TILE_COUNT = TILE_COLS * TILE_ROWS;
    const TILE_W = canvas.width / TILE_COLS;
    const TILE_H = canvas.height / TILE_ROWS;

    const tiles = [];

    function initTiles() {
      tiles.length = 0;
      for (let ty = 0; ty < TILE_ROWS; ty++) {
        for (let tx = 0; tx < TILE_COLS; tx++) {
          const index = ty * TILE_COLS + tx;
          const cx = tx * TILE_W + TILE_W / 2;
          const cy = ty * TILE_H + TILE_H / 2;
          const r = Math.min(TILE_W, TILE_H) * 0.35;

          tiles.push({
            cx,
            cy,
            radius: r,
            phase: Math.random() * Math.PI * 2,
            offset: (index * 7) % 60  // different slice of FIB60
          });
        }
      }
    }

    // -------- 5. Geometry maps: circle & triangle --------
    function circlePos(tile, i, timeShift) {
      const { cx, cy, radius } = tile;
      const angle = (2 * Math.PI * (i + timeShift)) / 60;
      return {
        x: cx + radius * Math.cos(angle),
        y: cy + radius * Math.sin(angle)
      };
    }

    // Triangle: perimeter cut into 60 points: 20 base, 20 vertical leg, 20 hypotenuse.
    function trianglePos(tile, i) {
      const { cx, cy, radius } = tile;
      const base = radius * 2 * 0.85;
      const height = radius * 2 * 0.85;

      const x0 = cx - base / 2;
      const y0 = cy + height / 2; // bottom-left

      let x, y;
      if (i < 20) {
        const t = i / 19;
        x = x0 + base * t;
        y = y0;
      } else if (i < 40) {
        const t = (i - 20) / 19;
        x = x0;
        y = y0 - height * t;
      } else {
        const t = (i - 40) / 19;
        const x1 = x0;
        const y1 = y0 - height;
        const x2 = x0 + base;
        const y2 = y0;
        x = x1 + (x2 - x1) * t;
        y = y1 + (y2 - y1) * t;
      }
      return { x, y };
    }

    // -------- 6. Rings (60 / 108 / 216-ish) --------
    function drawRings(tile) {
      const { cx, cy, radius } = tile;
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 0.6;

      const r1 = radius * 0.6;   // time 60
      const r2 = radius * 0.85;  // seed 108
      const r3 = radius * 1.05;  // spirit 216

      ctx.beginPath(); ctx.arc(cx, cy, r1, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, r2, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, r3, 0, Math.PI * 2); ctx.stroke();

      ctx.restore();
    }

    // -------- 7. Animation loop --------
    let running = true;

    function drawFrame(timestamp) {
      if (!running) return;
      const t = timestamp / 1000; // seconds

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Global morph factor: circle ↔ triangle
      const morph = 0.5 + 0.5 * Math.sin(t * 0.5);

      for (const tile of tiles) {
        const { phase, offset, cx, cy } = tile;

        // Per-tile phase so they don't sync
        const timeShift = (t * 2 + phase) / (2 * Math.PI);

        drawRings(tile);

        // 60 points around the cycle
        for (let i = 0; i < 60; i++) {
          const k = (i + offset) % 60;       // actual Fibonacci index
          const digit = FIB60[k];
          const sector = sectorForIndex(k);  // Lukas sector 0–11
          const sectorDigit = LUKAS_DIGITS[sector]; // 1..9

          const cPos = circlePos(tile, i, timeShift);
          const triPos = trianglePos(tile, i);

          let x = cPos.x * (1 - morph) + triPos.x * morph;
          let y = cPos.y * (1 - morph) + triPos.y * morph;

          // Radial scaling from Lukas digit: big sectors sit further out
          const dx = x - cx;
          const dy = y - cy;
          const radialScale = 0.75 + 0.3 * (sectorDigit / 9); // ~0.75..1.05
          x = cx + dx * radialScale;
          y = cy + dy * radialScale;

          const size = (Math.min(TILE_W, TILE_H) / 60) * 2.4;

          const baseColor = digitColors[digit];
          const rgb = hexToRgb(baseColor);

          // Brightness pulse: Fibonacci digit + Lukas sector digit
          const pulse =
            0.6 +
            0.25 * Math.sin(t * 2 + digit + phase) +
            0.1 * ((sectorDigit - 5) / 5);

          const r = clamp(Math.floor(rgb.r * pulse), 0, 255);
          const g = clamp(Math.floor(rgb.g * pulse), 0, 255);
          const b = clamp(Math.floor(rgb.b * pulse), 0, 255);

          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(x - size / 2, y - size / 2, size, size);
        }
      }

      requestAnimationFrame(drawFrame);
    }

    function hexToRgb(hex) {
      hex = hex.replace("#", "");
      const bigint = parseInt(hex, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    }

    function clamp(v, lo, hi) {
      return Math.max(lo, Math.min(hi, v));
    }

    // -------- 8. Controls --------
    const startBtn   = document.getElementById("startBtn");
    const stopBtn    = document.getElementById("stopBtn");
    const shuffleBtn = document.getElementById("shuffleBtn");

    startBtn.addEventListener("click", () => {
      if (!running) {
        running = true;
        requestAnimationFrame(drawFrame);
      }
    });

    stopBtn.addEventListener("click", () => {
      running = false;
    });

    shuffleBtn.addEventListener("click", () => {
      // Randomise tile phases & offsets
      tiles.forEach((tile, idx) => {
        tile.phase = Math.random() * Math.PI * 2;
        tile.offset = (idx * 7 + Math.floor(Math.random() * 60)) % 60;
      });
    });

    // -------- 9. Init --------
    initTiles();
    requestAnimationFrame(drawFrame);
  </script>
</body>
</html>
